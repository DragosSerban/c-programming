Task 1:
- In fisierul Task1.c se regaseste prima oara o functie pentru a determina daca un numar de tip int primit parametru este prim sau nu.
- Mai departe se regaseste o functie pentru a determina daca un numar de tip int primit parametru este palindrom sau nu (adica daca este egal cu oglinditul sau).
- Urmeaza citirea dimensiunilor matricei, urmata de caracterul '\n', iar mai apoi stringul propriu-zis, cu fgets, asa ca va trebui sa eliminam caracterul '\n' aflat la finalul stringului, inainte de '\0'.
- Apoi se iau la rand caracterele sirului, pentru a cauta cuvintele ce incep cu 'a', 'b' sau 'c'.
- In cuvintele care incep cu 'a' se cauta pe ce pozitie se afla cel mai mare caracter citit dupa caracterul 'a', comparand fiecare dintre ultimele 3 caractere ale cuvantului cu primul care reprezinta o cifra in codul ASCII. Apoi se completeaza corespunzator matricea.
- Pentru cuvintele care incep cu 'b', formam numerele n si k ajutandu-ne de codul ASCII, stiind ca limita superioara a cuvantului este marcata de caracterul '\0' sau de ' '. Apoi ne folosim de functiile de numar prim pentru k si de palindrom pentru n scrise la inceput de fisier si se completeaza corespunzator matricea.
- Pentru cuvintele care incep cu 'c', initializam n si k, folosindu-ne de pozitia lui '0' in ASCII. Initializam counter cu k, deoarece vom modifica variabila k (deoarece daca k > n, atunci xi merge din a*n+(k-a*n) in a*n+(k-a*n), deci practic in acest caz din k-a*n in k-a*n, asa ca vom folosi un while pentru a ajunge la un k mai mic astfel incat sa ne usuram munca. Se foloseste un for intr-un while pentru a realiza adunarea S si pentru a o lua intotdeauna de la x0 atunci cand se trece de limita superioara a cuvantului. Se afla rezultatul lui S%4 si se completeaza corespunzator matricea.
- La final se afiseaza matricea finala (drumul prin labirint).

Task 2:
- Se citeste stringul si se verifica cu strcmp daca cifrul ce urmeaza a fi citit este pentru caesar, vigenere sau addition.
- Daca este caesar, atunci se citeste cheia, se citeste stringul, se elimina '\n' (a fost citit cu fgets) si se modifica caracterele cu ajutorul functiei cifruCaesar. In functie, cu ajutorul variabilelor firstChar si lastChar se afla numarul de caractere al secventei din care face parte caracterul curent in codul ASCII. Daca K e mai mai mare decat numarul respectiv, atunci se scade numberOfChars din K cat timp este valida operatia aceasta. Daca caracterul curent minus K nu trece de limita inferioara a secventei din ASCII, atunci se modifica prin scadere. Altfel, se calculeaza diferenta dintre caracterul ce trebuie schimbat si primul caracter al secventei, iar apoi din K se scade acest numar, urmand ca mai apoi sa se scada din ultimul caracter al secventei ceea ce a devenit K anterior.
- Daca este vigenere, atunci se citeste cheia, apoi stringul. Se ia pe rand fiecare caracter din string, se face o noua variabila in care este pus caracterul corespunzator din K, iar apoi se foloseste functia cifruVigenere, care functioneaza aproximativ la fel ca functia pentru caesar, doar ca primeste ca parametru un (char)K in loc de (int)K.
- Daca este addition, se citeste cheia, apoi se citesc cele 2 stringuri, apoi le modificam cu functia cifruCaesar fiecare caracter. Se verifica care din cele 2 stringuri este mai lung, iar cel mai scurt va deveni de aceeasi lungime, deoarece se va completa sirul scurt cu mai multe pozitii, la final mutandu-se cele care se aflau inainte pe primele pozitii, iar pe primele pozitii va aparea caracterul '0'. Se incepe adunarea propriu-zisa, utilizand un for si variabila rest, care semnifica daca suma celor 2 elemente de pe pozitia i (S1[i] si S2[i]), dupa ce sunt traduse din ASCII, prin -2*'0' este peste ordin (rest = 1) sau nu (rest = 0). Daca rest = 1, atunci acesta se adauga la urmatoarea operatie. Se observa ca S este intotdeauna pe o pozitie mai mare decat S1 si S2, pentru ca vom pastra pozitia S[0] in caz ca suma celor 2 numere are mai multe cifre decat oricare dintre cele 2 numere. La final se verifica daca suma este zero sau nu si se afiseaza.

Task 3:
- Declaram un vector de pointeri pe care il vom utiliza ulterior si un vector de separatori pentru functia strtok.
- Cat timp citim de la tastatura aliniate cu fgets, le concatenam pe acestea la s.
- Folosim functia strtok pentru a imparti textul din s in cuvinte, iar elementele din vectorul de pointeri vor puncta catre p (care este un pointer ce puncteaza de fiecare data spre un cuvant din s (strtok inlocuieste unde gaseste separatori cu '\0')).
- Folosim un for pentru a parcurge toate cuvintele spre care pointeaza vectorul de pointeri. Initializam stringurile word1[MAX] si word2[MAX], care vor contine cuvantul asociat pozitiei i din vectorul de pointeri si respectiv cel al pozitiei (i+1).
- Initializam numberOfAppearances = 1. Verificam de cate ori se gaseste 2grama actuala in string, folosindu-ne de pozitiile urmatoare ale vectorului de pointeri si de functia strcmp. Daca mai gasim 2grama, numberOfAppearances++.
- Daca am mai intalnit 2grama actuala anterior, atunci dontPrint = 1 si trecem mai departe. Daca dontPrint == 0, atunci numberOf2grams++ si concatenam la output sirul format din word1, word2 si numberOfAppearances (ale carui cifre sunt transformate in caracterele corespunzatoare in ASCII cu ajutorul snprintf).
- La final afisam numberOf2grams si output, adica 2gramele si numarul lor de aparitii.
